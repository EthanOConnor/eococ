<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>COC Newsletter Proofing Viewer</title>
  <style>
    :root {
      --gutter: 6px;
      --bg: #0b0f14;
      --panel: #0f1621;
      --text: #e6edf3;
      --muted: #8aa1b4;
      --accent: #5eb1ff;
      --danger: #ff6b6b;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: var(--sans); }

    .btn { padding: 8px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.12); background: #152031; color: var(--text); cursor: pointer; text-decoration: none; display: inline-flex; align-items: center; gap: 6px; }
    .btn.secondary { background: transparent; }
    .btn:disabled, .btn.disabled, .btn[aria-disabled="true"] { opacity: 0.4; cursor: not-allowed; pointer-events: none; }

    .header { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 16px; padding: 14px 18px; background: rgba(255,255,255,0.04); border-bottom: 1px solid rgba(255,255,255,0.08); }
    .header h1 { margin: 0; font-size: 20px; font-weight: 600; }
    .header .meta { color: var(--muted); font-size: 14px; display: flex; gap: 16px; flex-wrap: wrap; margin-top: 6px; }
    .header .meta span { display: inline-flex; gap: 6px; align-items: center; }
    .header .meta strong { color: var(--text); }
    .header .actions { display: inline-flex; gap: 10px; flex-wrap: wrap; }

    .split { display: flex; height: calc(100% - 70px); }
    .pane { overflow: hidden; position: relative; background: var(--panel); }

    .pdfwrap { position: absolute; inset: 0; }
    .pdfwrap iframe, .pdfwrap embed { width: 100%; height: 100%; border: 0; background: #1a2331; }

    .mdwrap { position: absolute; inset: 0; display: grid; grid-template-rows: auto 1fr; }
    .mdtabs { display: inline-flex; gap: 6px; padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.03); }
    .mdtabs .tab { padding: 6px 10px; border-radius: 8px; cursor: pointer; color: var(--muted); }
    .mdtabs .tab[aria-selected="true"] { color: var(--text); background: rgba(255,255,255,0.06); }

    .mdcontent { position: relative; overflow: auto; padding: 18px 24px; }
    .rendered { line-height: 1.55; max-width: 68ch; }
    pre.raw { white-space: pre-wrap; word-wrap: break-word; font-family: var(--mono); font-size: 14px; background: #0c131d; border: 1px solid rgba(255,255,255,0.08); border-radius: 10px; padding: 16px; }

    .gutter { background: transparent; position: relative; }
    .gutter:after { content: ""; position: absolute; inset: 0; width: 6px; margin: 0 auto; background: rgba(255,255,255,0.08); border-radius: 3px; }
    .gutter.gutter-horizontal { cursor: col-resize; width: 10px; }

    .control-drawer { position: fixed; left: 0; right: 0; bottom: 0; background: rgba(12,18,30,0.95); border-top: 1px solid rgba(255,255,255,0.08); box-shadow: 0 -12px 28px rgba(0,0,0,0.45); transform: translateY(calc(100% - 42px)); transition: transform 0.25s ease; backdrop-filter: blur(6px); }
    .control-drawer.open { transform: translateY(0); }
    .drawer-handle { background: none; border: 0; color: var(--muted); width: 100%; padding: 10px; cursor: pointer; font-size: 13px; display: flex; gap: 8px; align-items: center; justify-content: center; }
    .drawer-content { padding: 12px 18px 18px; display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 16px; align-items: end; }
    .drawer-content label { display: flex; flex-direction: column; gap: 6px; font-size: 13px; color: var(--muted); }
    .drawer-content input[type="text"] { padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.12); background: var(--panel); color: var(--text); }
    .drawer-actions { display: flex; flex-direction: column; gap: 10px; }
    .btn-group { display: inline-flex; gap: 6px; flex-wrap: wrap; }
    .drawer-actions .btn-group .btn { padding: 8px 12px; }
    .drawer-actions .btn-link { display: inline-flex; gap: 6px; }
    .drawer-actions .notice { font-size: 12px; color: var(--muted); }

    a, a:visited { color: var(--accent); }
    .notice { color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <div class="header">
    <div>
      <h1 id="issueTitle">Proofing Viewer</h1>
      <div class="meta" id="issueMeta"></div>
    </div>
    <div class="actions">
      <button id="prevIssue" class="btn secondary">← Previous</button>
      <button id="nextIssue" class="btn secondary">Next →</button>
      <a id="openDashboard" class="btn">Dashboard</a>
      <button id="toggleViewBtn" class="btn" aria-pressed="false" title="Toggle Rendered/Raw (R)">Rendered</button>
    </div>
  </div>

  <div id="split" class="split">
    <div id="pdfPane" class="pane">
      <div class="pdfwrap">
        <iframe id="pdfFrame" title="PDF viewer"></iframe>
      </div>
    </div>

    <div id="mdPane" class="pane">
      <div class="mdwrap">
        <div class="mdtabs">
          <div id="tabRendered" class="tab" role="tab" aria-selected="true">Rendered</div>
          <div id="tabRaw" class="tab" role="tab" aria-selected="false">Raw</div>
        </div>
        <div class="mdcontent">
          <article id="rendered" class="rendered" hidden></article>
          <pre id="raw" class="raw" hidden></pre>
        </div>
      </div>
    </div>
  </div>

  <div id="controlDrawer" class="control-drawer">
    <button id="drawerToggle" class="drawer-handle">Show controls ▴</button>
    <div class="drawer-content">
      <label>
        PDF (left)
        <input id="pdfInput" type="text" placeholder="newsletters/1978/.../scan_fullsize.pdf" />
      </label>
      <label>
        Markdown (right)
        <input id="mdInput" type="text" placeholder="newsletters/transcripts/1978/... .md" />
      </label>
      <div class="drawer-actions">
        <div class="btn-group">
          <button class="btn" id="prevPage">◀ Page</button>
          <button class="btn" id="nextPage">Page ▶</button>
          <button class="btn" id="fitBtn">Fit</button>
        </div>
        <div class="btn-group">
          <button id="loadBtn" class="btn">Load</button>
          <a id="openPdfLink" class="btn" target="_blank" rel="noopener">Open PDF</a>
          <a id="openMdLink" class="btn" target="_blank" rel="noopener">Open MD</a>
        </div>
        <span class="notice" id="pdfNotice"></span>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/split.js/dist/split.min.js"></script>
  <script src="vendor/marked.js"></script>
  <script src="vendor/purify.min.js"></script>
  <script>
    const $ = (s) => document.querySelector(s);
    const markedLib = (typeof window !== "undefined" && window.marked) ? window.marked : (typeof marked !== "undefined" ? marked : null);
    const domPurifyLib = (typeof window !== "undefined" && window.DOMPurify) ? window.DOMPurify : (typeof DOMPurify !== "undefined" ? DOMPurify : null);
    const PATH_MATCH = location.pathname.match(/^(.*)\/proof\/index\.html$/);
    const SITE_BASE = PATH_MATCH ? PATH_MATCH[1] : '';
    const BASE_URL = `${location.origin}${SITE_BASE ? SITE_BASE + '/' : '/'}`;
    const monthName = (m)=> new Date(2000, (m||1)-1, 1).toLocaleString(undefined, { month: 'short' });
    const isAbsoluteUrl = (p)=> /^(?:[a-z]+:)?\/\//i.test(p);
    const toAbsolute = (p)=>{
      if (!p) return null;
      if (isAbsoluteUrl(p)) return p;
      const cleaned = p.replace(/^\/+/, '');
      return new URL(cleaned, BASE_URL).href;
    };
    const toInputValue = (p)=>{
      if (!p) return '';
      if (isAbsoluteUrl(p)){
        if (p.startsWith(BASE_URL)) return p.slice(BASE_URL.length);
        if (p.startsWith(location.origin)) return p.slice(location.origin.length);
        return p;
      }
      const cleaned = p.replace(/^\/+/, '');
      return cleaned;
    };
    const normalizePath = (p)=>{
      if (!p) return null;
      try{
        const abs = toAbsolute(p) || p;
        const url = new URL(abs, BASE_URL);
        return url.pathname.replace(/\/+/g,'/').replace(/\/$/,'');
      }catch{
        return ('/' + p.replace(/^\/+/, '')).replace(/\/+/g,'/').replace(/\/$/,'');
      }
    };
    Split(["#pdfPane", "#mdPane"], { sizes: [50, 50], minSize: 200, gutterSize: 10 });

    const mdInput = $("#mdInput");
    const pdfInput = $("#pdfInput");
    const loadBtn = $("#loadBtn");
    const openMdLink = $("#openMdLink");
    const openPdfLink = $("#openPdfLink");
    const openDashboardLink = $("#openDashboard");
    const pdfFrame = $("#pdfFrame");
    const pdfNotice = $("#pdfNotice");
    const rendered = $("#rendered");
    const raw = $("#raw");
    const tabRendered = $("#tabRendered");
    const tabRaw = $("#tabRaw");
    const toggleViewBtn = $("#toggleViewBtn");
    const prevPageBtn = $("#prevPage");
    const nextPageBtn = $("#nextPage");
    const fitBtn = $("#fitBtn");
    const prevIssueBtn = $("#prevIssue");
    const nextIssueBtn = $("#nextIssue");
    const issueTitleEl = $("#issueTitle");
    const issueMetaEl = $("#issueMeta");
    const drawer = $("#controlDrawer");
    const drawerToggle = $("#drawerToggle");
    let currentFrontMatter = null;
    pdfNotice.textContent = "No PDF selected.";
    openPdfLink.classList.add("disabled");
    openPdfLink.setAttribute("aria-disabled", "true");
    openMdLink.classList.add("disabled");
    openMdLink.setAttribute("aria-disabled", "true");
    prevIssueBtn.disabled = true;
    nextIssueBtn.disabled = true;

    const qs = new URLSearchParams(location.search);
    let current = { md: "", pdf: "", page: parseInt(qs.get("page") || "1", 10) };
    let view = qs.get("view") || "rendered";
    const mdParam = qs.get("md") || "";
    const pdfParam = qs.get("pdf") || "";
    mdInput.value = toInputValue(mdParam);
    pdfInput.value = toInputValue(pdfParam);
    const dashboardUrl = new URL('dashboard/index.html', BASE_URL).href;
    if (openDashboardLink) openDashboardLink.href = dashboardUrl;

    const issuesUrl = new URL('data/newsletters.json', BASE_URL).href;
    let issues = [];
    let currentIssueIndex = -1;

    document.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === "r" && !e.metaKey && !e.ctrlKey) { e.preventDefault(); toggleView(); }
      if (e.key === "ArrowLeft" && !e.metaKey && !e.ctrlKey) { e.preventDefault(); navigateIssue(-1); }
      if (e.key === "ArrowRight" && !e.metaKey && !e.ctrlKey) { e.preventDefault(); navigateIssue(1); }
    });
    tabRendered.addEventListener("click", () => setView("rendered"));
    tabRaw.addEventListener("click", () => setView("raw"));
    toggleViewBtn.addEventListener("click", toggleView);
    drawerToggle.addEventListener("click", () => {
      drawer.classList.toggle("open");
      drawerToggle.textContent = drawer.classList.contains("open") ? "Hide controls ▾" : "Show controls ▴";
    });

    const updateToggleButton = () => {
      toggleViewBtn.textContent = view === "rendered" ? "Rendered" : "Raw";
      toggleViewBtn.setAttribute("aria-pressed", (view !== "rendered").toString());
    };

    function setView(v){
      view = v;
      const isRendered = v === "rendered";
      rendered.hidden = !isRendered; raw.hidden = isRendered;
      tabRendered.setAttribute("aria-selected", isRendered);
      tabRaw.setAttribute("aria-selected", !isRendered);
      updateToggleButton();
      writeUrlParams(current.md, current.pdf);
    }
    function toggleView(){ setView(view === "rendered" ? "raw" : "rendered"); }

    function setPdf(url){
      current.pdf = url || "";
      const absolute = toAbsolute(url);
      if (!absolute) {
        pdfFrame.removeAttribute("src");
        openPdfLink.removeAttribute("href");
        openPdfLink.classList.add("disabled");
        openPdfLink.setAttribute("aria-disabled", "true");
        pdfNotice.textContent = "No PDF selected.";
        return;
      }
      openPdfLink.href = absolute;
      openPdfLink.classList.remove("disabled");
      openPdfLink.removeAttribute("aria-disabled");
      const base = absolute.split("#")[0];
      const safePage = Math.max(1, current.page || 1);
      current.page = safePage;
      const pdfURL = `${base}#page=${safePage}&zoom=page-fit`;
      pdfFrame.src = pdfURL;
      pdfNotice.textContent = `Page ${safePage}. Use Page controls or open PDF in new tab for full tools.`;
    }
    prevPageBtn.addEventListener("click", () => {
      if (!current.pdf) return;
      if (current.page > 1) {
        current.page--;
        setPdf(current.pdf);
        writeUrlParams(current.md, current.pdf);
      }
    });
    nextPageBtn.addEventListener("click", () => {
      if (!current.pdf) return;
      current.page++;
      setPdf(current.pdf);
      writeUrlParams(current.md, current.pdf);
    });
    fitBtn.addEventListener("click", () => {
      if (!current.pdf) return;
      setPdf(current.pdf);
    });

    function splitFrontMatter(mdText){
      const match = mdText.match(/^---\s*\n([\s\S]*?)\n---\s*\n?/);
      if (!match) return { body: mdText, front: null };
      const body = mdText.slice(match[0].length);
      return { body, front: match[1] };
    }

    function parseFrontMatter(front){
      if (!front) return null;
      const data = {};
      const lines = front.split(/\r?\n/);
      for (const line of lines){
        const m = line.match(/^([A-Za-z0-9_]+):\s*(.*)$/);
        if (!m) continue;
        const key = m[1];
        let value = m[2].trim();
        if (/^['"].*['"]$/.test(value)) value = value.slice(1, -1);
        if (["year","month","volume","issue_number"].includes(key)){
          const num = Number(value);
          if (!Number.isNaN(num)) value = num;
        }
        data[key] = value;
      }
      return data;
    }

    async function setMd(url){
      current.md = url || "";
      const absolute = toAbsolute(url);
      if (absolute) {
        openMdLink.href = absolute;
        openMdLink.classList.remove("disabled");
        openMdLink.removeAttribute("aria-disabled");
      } else {
        openMdLink.removeAttribute("href");
        openMdLink.classList.add("disabled");
        openMdLink.setAttribute("aria-disabled", "true");
      }
      if (!absolute) { rendered.innerHTML = ""; raw.textContent = ""; currentFrontMatter = null; return; }
      try {
        const res = await fetch(absolute, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const mdText = await res.text();
        const { body, front } = splitFrontMatter(mdText);
        currentFrontMatter = parseFrontMatter(front);
        const bodyContent = body.replace(/^\s*/, "");
        raw.textContent = bodyContent;
        if (!markedLib) throw new Error("marked is not loaded");
        if (!domPurifyLib) throw new Error("DOMPurify is not loaded");
        const html = markedLib.parse(bodyContent, { mangle: false, headerIds: true, gfm: true });
        const clean = domPurifyLib.sanitize(html, { USE_PROFILES: { html: true, svg: true }, ADD_ATTR: ["target", "rel"] });
        rendered.innerHTML = clean;
      } catch (err){
        rendered.innerHTML = `<p style="color: var(--danger)">Failed to load markdown: ${err.message}</p>`;
        raw.textContent = "";
        currentFrontMatter = null;
      }
    }

    function writeUrlParams(mdPath, pdfPath){
      const url = new URL(location.href);
      if (mdPath) url.searchParams.set("md", mdPath); else url.searchParams.delete("md");
      if (pdfPath) url.searchParams.set("pdf", pdfPath); else url.searchParams.delete("pdf");
      if (current.page && current.page > 1) url.searchParams.set("page", String(current.page)); else url.searchParams.delete("page");
      if (view) url.searchParams.set("view", view);
      history.replaceState({}, "", url);
    }

    const stageDone = (value)=>{
      if (!value) return false;
      if (typeof value === "boolean") return value;
      if (typeof value === "object" && value.state) return value.state === "done";
      return false;
    };

    function formatStatusIcon(done, label){
      const symbol = done ? "✓" : "•";
      return `${label} <strong>${symbol}</strong>`;
    }

    function updateHeader(issue){
      let meta = issue || null;
      let status = (issue && issue.status) || {};
      if (!meta && currentFrontMatter){
        meta = currentFrontMatter;
      }
      if (!meta){
        issueTitleEl.textContent = "Proofing Viewer";
        issueMetaEl.innerHTML = '<span>No newsletter selected.</span>';
        document.title = "COC Proofing Viewer";
        return;
      }
      issueTitleEl.textContent = meta.name || `Issue ${meta.id || ''}`.trim() || "Proofing Viewer";
      document.title = `${meta.name || meta.id || 'Viewer'} — COC Proof`;
      const parts = [];
      if (meta.id) parts.push(`ID <strong>${meta.id}</strong>`);
      if (meta.year){
        const month = meta.month ? monthName(Number(meta.month)) + " " : "";
        parts.push(`Date <strong>${month}${meta.year}</strong>`);
      }
      if (meta.volume) parts.push(`Volume <strong>${meta.volume}</strong>`);
      if (meta.issue_number) parts.push(`No. <strong>${meta.issue_number}</strong>`);
      if (meta.scan_description) parts.push(`Scan <strong>${meta.scan_description}</strong>`);
      const scanFull = formatStatusIcon(stageDone(status.scan_fullsize), "Fullsize");
      const scanArch = formatStatusIcon(stageDone(status.scan_archival), "Archival");
      parts.push(scanFull, scanArch);
      const transcriptDone = stageDone(status.transcript_review2) || stageDone(status.transcript_review1) || stageDone(status.transcript_auto);
      parts.push(formatStatusIcon(transcriptDone, "Transcript"));
      issueMetaEl.innerHTML = parts.map(part => `<span>${part}</span>`).join("");
    }

    function updateNavButtons(){
      const hasPrev = currentIssueIndex > 0;
      const hasNext = currentIssueIndex >= 0 && currentIssueIndex < issues.length - 1;
      prevIssueBtn.disabled = !hasPrev;
      nextIssueBtn.disabled = !hasNext;
    }

    function bestPdfForIssue(issue){
      if (!issue) return "";
      const files = issue.files || {};
      return files.pdf_fullsize || files.pdf_archival || files.pdf || files.pdf_initial || "";
    }

    function updateIssueContext(){
      if (!issues.length){
        currentIssueIndex = -1;
        updateHeader(null);
        updateNavButtons();
        return;
      }
      const mdNorm = normalizePath(current.md);
      const pdfNorm = normalizePath(current.pdf);
      const idx = issues.findIndex(issue => {
        const files = issue.files || {};
        if (mdNorm && files.md && normalizePath(files.md) === mdNorm) return true;
        const pdfCandidates = ['pdf_fullsize','pdf_archival','pdf','pdf_initial'];
        if (pdfNorm) return pdfCandidates.some(k => files[k] && normalizePath(files[k]) === pdfNorm);
        return false;
      });
      currentIssueIndex = idx;
      const issue = idx >= 0 ? issues[idx] : null;
      updateHeader(issue);
      updateNavButtons();
    }

    async function loadContent(mdPath, pdfPath){
      const trimmedMd = mdPath ? mdPath.trim() : "";
      const trimmedPdf = pdfPath ? pdfPath.trim() : "";
      const previousPdf = current.pdf;
      await setMd(trimmedMd);
      if (normalizePath(trimmedPdf) !== normalizePath(previousPdf)) current.page = 1;
      setPdf(trimmedPdf);
      writeUrlParams(trimmedMd, trimmedPdf);
      updateIssueContext();
      setView(view || "rendered");
    }

    async function loadIssueByIndex(index){
      const issue = issues[index];
      if (!issue) return;
      currentIssueIndex = index;
      const mdPath = issue.files?.md || "";
      const pdfPath = bestPdfForIssue(issue);
      mdInput.value = toInputValue(mdPath);
      pdfInput.value = toInputValue(pdfPath);
      await loadContent(mdInput.value, pdfInput.value);
    }

    async function navigateIssue(delta){
      if (!issues.length) return;
      const target = currentIssueIndex === -1 ? (delta > 0 ? 0 : issues.length - 1) : currentIssueIndex + delta;
      if (target < 0 || target >= issues.length) return;
      try {
        await loadIssueByIndex(target);
      } catch (err) {
        console.error('Failed to navigate issue', err);
      }
    }

    async function fetchIssues(){
      try{
        const res = await fetch(issuesUrl, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();
        const arr = Array.isArray(json) ? json : (json.issues || []);
        return arr.slice().sort((a,b)=> (a.id || "").localeCompare(b.id || ""));
      }catch(err){
        console.warn("Failed to load newsletters dataset", err);
        return [];
      }
    }

    loadBtn.addEventListener("click", async () => {
      await loadContent(mdInput.value, pdfInput.value);
    });
    prevIssueBtn.addEventListener("click", () => navigateIssue(-1));
    nextIssueBtn.addEventListener("click", () => navigateIssue(1));

    (async function init(){
      issues = await fetchIssues();
      if (mdParam || pdfParam){
        await loadContent(mdParam, pdfParam);
      } else {
        updateIssueContext();
        setView(view || "rendered");
      }
    })();
  </script>
</body>
</html>
